1.用css 实现居中有哪些⽅法
1.1水平居中：
1.1.1内联元素水平居中
利用 text-align: center 可以实现在块级元素内部的内联元素水平居中。此方法对内联元素(inline), 内联块(inline-block), 内联表(inline-table), inline-flex元素水平居中都有效。
1.1.2 块级元素水平居中
通过把固定宽度块级元素的margin-left和margin-right设成auto，就可以使块级元素水平居中。
1.1.3 利用inline-block
如果一行中有两个或两个以上的块级元素，通过设置块级元素的显示类型为inline-block和父容器的text-align属性从而使多块级元素水平居中。
1.1.4利用display: flex
利用弹性布局flex，实现水平居中，其中justify-content用于设置弹性盒子元素在主轴（横轴）方向上的对齐方式，
1.2、垂直居中
1.2.1单行内联(inline-)元素垂直居中 
通过设置内联元素的高度(height)和行高(line-height)相等，从而使元素垂直居中。
1.2.2 利用flex布局（flex）
利用flex布局实现垂直居中，其中flex-direction: column定义主轴方向为纵向
1.2.3 固定高度的块级元素
我们知道居中元素的高度和宽度，垂直居中问题就很简单。通过绝对定位元素距离顶部50%，并设置margin-top向上偏移元素高度的一半，就可以实现垂直居中了。
1.2.4 未知高度的块级元素
当垂直居中的元素的高度和宽度未知时，我们可以借助CSS3中的transform属性向Y轴反向偏移50%的方法实现垂直居中。但是部分浏览器存在兼容性的问题。
1.3、水平垂直居中
1.3.1 固定宽高元素水平垂直居中
通过绝对定位，配合margin
1.3.2 未知宽高元素水平垂直居中
通过绝对定位，配合transform
1.3.3  利用flex布局
利用flex布局，其中justify-content 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式；而align-items属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。
1.3.4 屏幕上水平垂直居中
.element{
    width: 300px;
    height: 300px;
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    margin: auto;
}

2. 什么是语义化的HTML?有何意义？为什么要做到语义化？
2.1 用正确的标签做正确的事情,让页面的内容结构化，够便于开发者阅读，便于被浏览器、搜索引擎解析
2.2 有利于SEO，有利于搜索引擎爬虫更好的理解我们的网页，从而获取更多的有效信息，提升网页的权重。
2.3 在没有CSS的时候能够清晰的看出网页的结构，增强可读性。
2.4 便于团队开发和维护，语义化的HTML可以让开发者更容易的看明白，从而提高团队的效率和协调能力。

3. javascript的typeof返回哪些数据类型.
3.1 number
3.2 string
3.3 boolean
3.4 null
3.5 undefined
3.6 object
3.7 symbol

4. 数组有哪些常用⽅法，作⽤是什么？
splice()删除
slice()基于当前数组创建新数组
join()转换为字符串
concat()合并数组
indexOf()查找数组中元素的索引
reverse()反转
sort()比较
forEach()遍历
map()映射
filter()过滤

5. js都有哪些方式可以实现继承（包含ES6)？
属性继承通过call(this,属性1，属性2，...)
5.1 构造函数继承 利用call，apply，bind借用父类的构造函数，缺点：无法继承原型链上的属性和方法
5.2 原型链继承 利用原型链来实现继承，父类的一个实例作为子类的原型，也就是 子构造函数.prototype = new 父构造函数()。缺点：当父类中包含引用类型属性值时，其中一个子类的多个实例中，只要其中一个实例引用属性只发生修改一个修改，其他实例的引用类型属性值也会立即发生改变，原因是父类的属性变成子类的原型属性
5.3 组合继承：构造函数继承+原型链继承(实际开发项目常用)
也叫伪经典继承，将原型链和借用构造函数的技术组合到一块。使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承。
属性继承通过call(this, 参数1，参数2，...)
子类.prototype = new 父类();缺点：父类的构造函数被调用两次，在子类的原型上产生了不必要的父类的属性
子类.prototype = Object.create(父类.prototype);Object.create(参数)会创建一个新对象,新创建对象的__proto__对象就是参数，此方法比较好用
5.4 es6的extends
constructor(name,age){
	super(name,age);
}
属性通过调用super()方法继承，在父类定义的方法可以直接继承，静态方法也可以直接继承

6. 原⽣JS 添加 删除 替换 插入到某个dom接点的⽅方法？
6.1 添加元素 document.createElement('标签名')
		该方法会返回一个DOM节点
		创建的元素并不会插入到页面
		需要用追加或者插入方法来将新创建的元素插入到页面
6.2 删除元素 parentNode.removeChild(node)：在父元素中删除指定的子节点
6.3 插入元素 parentNode.insertBefore(node1,node2)：在父节点中的node2之前插入node1
6.4 追加元素 parentNode.appendChild(node)：将指定节点追加到父节点的最后面，appendChild会把要追加的节点从原父节点中删除
6.5 克隆节点 oNode.cloneNode([true])
		参数true表示克隆节点的同时克隆所有后代
		不带参数true只克隆节点
		需要用追加或者插入方法来将克隆的元素插入到页面

7. 降维数组 例例如（var arr=[[1,2],[3,4]]; 转换为[1,2,3,4]）
7.1 利用es6扩展运算符
res=[].concat(...arr)
7.2 用apply的特性，将数组作为参数展开
res=[].concat.apply([],...arr)
7.3 es6中的flat方法:flat方法默认没有参数，这时只会降维降一层。可以传数字类型的参数指定降维次数。
res=arr.flat()

8. 怎么来判断一个对象是数组、对象、函数
8.1 Array.isArray()判断传入的对象是否是数组，typeof可以判断对象是否是函数
8.2 检测出所有的类型 Object.prototype.toString.call()

9. 数组去重
方法一：先将原数组排序，在与相邻的进行比较，如果不同则存入新数组。
方法二：利用对象属性无序唯一，如果没有该属性则存入新数组
方法三：利用数组的indexOf下标属性来查询。如果返回-1，说明新数组不存在此元素，存入新数组
方法四：利用es6的includes(搜索的值,[搜索的开始索引])方法，返回的是布尔值，用for循环遍历
方法五：利用es6的includes(搜索的值,[搜索的开始索引])方法和filter方法结合
方法六：利用 ES6的set 方法。Array.from(new Set(arr));

10. 不使用循环语句（包括map、forEach⽅法）实现一个100长度的数组，索引值和值相同的数组[0,1,2,3,4,5……..99]
10.1 Array.apply(null,{length:100}).map((item,index)=>{return index;})
10.2 Array.from({length:10}0).map((item,index)=>{return index;});
10.3 使用递归调用
var arr=[];
function makeArr(count,arr){
	count--;
	arr.unshift(count);
	if(count==0){
	    return;
	}else{
	   makeArr(count,arr); 
	   或使用arguments.callee(count,arr),但在严格模式下会失效 
	}
}
makeArr(100,arr);


11. 说说Cookie和Session的区别？
1、存放位置：Cookie和Session都是会话技术，Cookie是保存在客户端，Session是保存在服务器端。
2、Cookie有大小限制以及浏览器在存cookie的个数也有限制，Session没有大小限制和服务器的内存大小有关。
3、安全性：Cookie有安全隐患，通过拦截或本地文件找得到你的cookie后可以进行攻击。cookie是以明文的方式存放在客户端的，安全性低，可以通过一个加密算法进行加密后存放；session存放于服务器的内存中，所以安全性好
4、Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。

12. cookie、session存储在什么地方，作⽤是什么？
Cookie是保存在客户端，Session是保存在服务器端。
Cookie作用：记录客户端的状态信息,解决HTTP无状态的问题
Session作用：


13. localStorage 与 sessionStorage 有什么区别?
1.存储时效不同：localStorage持久化；sessionStorage网页会话结束失效
2.作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。


14. sessionStorage 、localStorage 和 cookie 之间的区别
共同点：都是保存在浏览器端，且同源的。
区别：
1.cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。
2.存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage可以达到5M或更大。
3.数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存；cookie只在设置的cookie过期时间之前一直有效。
4.作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。


15. null和undeﬁned的区别？
1.null是javascript的关键字，表示一个特殊值，常用来描述“空值“。undefined不是关键字，表示值的空缺，它是变量的一种取值，表明变量没有初始化。
2.用typeof运算符得到的null和undefined的类型分别为null、undefined
3.null和undefined用判断相等运算符==的结果是true，要使用严格相等运算符===来区分它们
4.在希望值是布尔值的地方它们的值都是false
5.使用情况区分：undefined是表示系统级的、出乎意料的类似错误的值的空缺。null是表示程序级别、正常的在意料之中的值的空缺。当需要作为参数传入函数时，用null更为合适。


16. ajax有哪些方法，get和post方式的区别？
1.方法：GET/POST/PUT/DELETE
2.区别：
2.1 可见性：get请求参数会暴露在地址栏中，post不会
2.2 get方式请求的数据会被浏览器缓存起来，而post请求不会
2.3 post的安全性更高
2.4 传输数据的大小：get一般传输数据大小不超过2k-4k（根据浏览器不同，限制不一样，但相差不大）
post请求传输数据的大小理论上没有限制。
2.5 后退页面的反应：get请求页面后退时，不产生影响；post请求页面后退时，会重新提交请求
2.6 get把请求的数据放在url上，即HTTP协议头上，其格式为：以?分割URL和传输数据，参数之间以&相连。
post把数据放在HTTP的包体内（requrest body）

17. 同源策略及限制？
源:协议+域名+端口
限制:不是一个源的文件不能操作另外一个源的文件,如Cookie/Storage/DOM/AJAX请求
不是一个源的文件操作另外一个源的文件就会形成跨域,即请求端的协议,域名,端口和服务器的协议,域名,端口有一个不一致就会发生跨域

18. 什么是ajax，它的原理是什么？它的优点和缺点有哪些？
含义：ajax是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。AJAX通过在后台与服务器进行少量的数据交换，可以使页面实现异步更新，这就意味着可以在不重新加载整个网页的情况下，对页面的某一部分进行数据的更新。
原理：通过XmlHttpRequest对象来向服务器发送异步请求，从服务器获得数据，然后用JavaScript来操作dom从而更新页面。
优点：
	1、实现了异步交互，提高了用户体验。异步与服务器通信：AJAX使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。
	2、页面无刷新更新数据
	3、AJAX是在客户端运行的，它承载了一部分本来由服务器承担的工作，减轻了服务器端的负担。
缺点：
	1、安全性问题，大量的使用AJAX暴露了服务器交互的细节。
	2、Ajax干掉了back按钮，即对浏览器后退机制的破坏。后退按钮是一个标准的web站点的重要功能，但是它没法和js进行很好的合作 。这是Ajax所 带来的一个比较严重的问题。
	3、对搜索引擎支持较弱：如果使用不当，AJAX会增大网络数据的流量，从而降低整个系统的性能。

19. 解释jsonp的原理，以及为什么不是真正的ajax，以及优缺点？
原理：动态创建script标签,利用script标签的src属性可以获取任何域下的js脚本,通过这个特性,服务器端返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域.
实质不同：ajax的核心是通过xmlHttpRequest获取非本页内容，jsonp的核心是动态添加script标签调用服务器提供的js脚本。
优点：完美解决在测试或者开发中获取不同域下的数据,用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback。参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。另外兼容性更好
缺点：只支持get请求而不支持post请求；安全性的问题

20. 什么是虚拟dom？
虚拟DOM指的是用js对象来模拟页面上dom元素的嵌套关系（DOM结构）的树形结构，减少了对真实的dom操作。因为DOM操作是’昂贵’ 的,在浏览器里一遍又一遍的渲染DOM非常消耗性能,为了提高性能,JS在V8引擎下运行效率是很高的,我们尽量减少DOM操作。

21. 常⻅的web攻击方式？
1. XSS（cross site script）跨站脚本攻击,XSS又称CSS，全称Cross SiteScript，跨站脚本攻击，是Web程序中常见的漏洞，XSS属于被动式且用于客户端的攻击方式，所以容易被忽略其危害性。其原理是攻击者向有XSS漏洞的网站中输入(传入)恶意的HTML代码，当其它用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如，盗取用户Cookie、破坏页面结构、重定向到其它网站等。
解决方法:一种方法是在表单提交或者url参数传递前，对需要的参数进行过滤。过滤用户输入的 检查用户输入的内容中是否有非法内容。如<>（尖括号）、”（引号）、‘（单引号）、%（百分比符号）、;（分号）、()（括号）、&（&符号）、+（加号）等。对所有用户提交内容进行可靠的输入验证
2. CSRF（cross-site request forgery）跨站请求伪造,指通过伪装成受信任用户的进行访问，通俗的讲就是说我访问了A网站，然后cookie存在了浏览器，然后我又访问了一个流氓网站，不小心点了流氓网站一个链接（向A发送请求），这个时候流氓网站利用了我的身份对A进行了访问。
解决方法：验证 HTTP Referer 字段 ;在请求地址中添加 token 并验证 ;在 HTTP 头中自定义属性并验证


document.write，innerHTML和innertext区别是什么？
document.write只能重绘整个页面
innerHTML可以重绘页面的一部分(包含标签+文字)
innertext可以重绘页面的一部分(只包含文字)
















Promise  的⽤用法，常⽤用api ？


手写ajax请求过程，选项卡，轮播图...



最近在看什么书，有没有学习计划









































































































































































































































































































